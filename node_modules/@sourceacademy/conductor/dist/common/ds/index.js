class t{t=[];i=[];push(t){this.i.push(t)}pop(){if(0===this.t.length){if(0===this.i.length)throw new Error("queue is empty");let t=this.t;this.t=this.i.reverse(),this.i=t}return this.t.pop()}get length(){return this.t.length+this.i.length}clone(){const s=new t;return s.t=[...this.t],s.i=[...this.i],s}}class s{h=new t;u=new t;push(t){0!==this.u.length?this.u.pop()(t):this.h.push(t)}async pop(){return 0!==this.h.length?this.h.pop():new Promise((t,s)=>{this.u.push(t)})}tryPop(){if(0!==this.h.length)return this.h.pop()}constructor(){this.push=this.push.bind(this)}}export{s as MessageQueue,t as Queue};
//# sourceMappingURL=index.js.map
